#define cptauanalysis_cxx
#include "cptauanalysis.h"
#include <TH2.h>
#include <TStyle.h>
#include <TCanvas.h>
#include <TLorentzVector.h>

void cptauanalysis::Loop()
{
//   In a ROOT session, you can do:
//      Root > .L cptauanalysis.C
//      Root > cptauanalysis t
//      Root > t.GetEntry(12); // Fill t data members with entry number 12
//      Root > t.Show();       // Show values of entry 12
//      Root > t.Show(16);     // Read and show values of entry 16
//      Root > t.Loop();       // Loop on all entries
//

//     This is the loop skeleton where:
//    jentry is the global entry number in the chain
//    ientry is the entry number in the current Tree
//  Note that the argument to GetEntry must be:
//    jentry for TChain::GetEntry
//    ientry for TTree::GetEntry and TBranch::GetEntry
//
//       To read only selected branches, Insert statements like:
// METHOD1:
//    fChain->SetBranchStatus("*",0);  // disable all branches
//    fChain->SetBranchStatus("branchname",1);  // activate branchname
// METHOD2: replace line
//    fChain->GetEntry(jentry);       //read all branches
//by  b_branchname->GetEntry(ientry); //read only this branch
   if (fChain == 0) return;

   // CP sensitive variables
   TH1F * hphip  = new TH1F( "hphip", "phip", 10, 0., 3.14);
   TH1F * hphim  = new TH1F( "hphim", "phim", 10, 0., 3.14);
   // pT pi- and photons
   TH1F * hptpipm  = new TH1F( "hptpipm", "pT pi+/- after selections", 50, 0., 100.);
   TH1F * hptgam  = new TH1F( "hptgam", "pT photons after selections", 50, 0., 100.);
   
   //
   TH1F * hdrpimpi01  = new TH1F( "hdrpimpi01", "DR(pi-,pi0), no selections", 50, 0., 0.5);
   TH1F * hdrpimpi01_s  = new TH1F( "hdrpimpi01_s", "DR(pi-,pi0), pT ro+/-  > 40 GeV", 50, 0., 0.5);

   // accceptance and off line cuts
   // pt of tau_h in off-line
   Double_t ptrocut = 40.;
   // eta acceptance for pi+/- and photons
   Double_t etacut = 1.479;
   // counts
   Double_t ntot = 0.;
   Double_t nsel = 0.;

   Long64_t nentries = fChain->GetEntriesFast();

   Long64_t nbytes = 0, nb = 0;
   for (Long64_t jentry=0; jentry<nentries;jentry++) {
      Long64_t ientry = LoadTree(jentry);
      if (ientry < 0) break;
      nb = fChain->GetEntry(jentry);   nbytes += nb;

      ntot += 1.;

      TLorentzVector pip, pim, pi01, pi02, rop, rom, tworo;
      // pi+
      pip.SetPx(ptpip*cos(phipip));
      pip.SetPy(ptpip*sin(phipip));
      Double_t theta = 2.*atan(exp(-etapip));
      pip.SetPz(ptpip/tan(theta));
      pip.SetE(ptpip/sin(theta));
      // pi-
      pim.SetPx(ptpim*cos(phipim));
      pim.SetPy(ptpim*sin(phipim));
      theta = 2.*atan(exp(-etapim));
      pim.SetPz(ptpim/tan(theta));
      pim.SetE(ptpim/sin(theta));
      // pi01
      pi01.SetPx(ptpi01*cos(phipi01));
      pi01.SetPy(ptpi01*sin(phipi01));
      theta = 2.*atan(exp(-etapi01));
      pi01.SetPz(ptpi01/tan(theta));
      pi01.SetE(ptpi01/sin(theta));
      // pi02
      pi02.SetPx(ptpi02*cos(phipi02));
      pi02.SetPy(ptpi02*sin(phipi02));
      theta = 2.*atan(exp(-etapi02));
      pi02.SetPz(ptpi02/tan(theta));
      pi02.SetE(ptpi02/sin(theta));
      // if (Cut(ientry) < 0) continue;
      rom = pim + pi01;
      rop = pip + pi02;
      tworo = rom + rop;
      Double_t ym = (pim.E()-pi01.E())/(pim.E()+pi01.E());
      Double_t yp = (pip.E()-pi02.E())/(pip.E()+pi02.E());
      // go to two ro center frame
      Double_t bx = -tworo.Px()/tworo.E();
      Double_t by = -tworo.Py()/tworo.E();
      Double_t bz = -tworo.Pz()/tworo.E();
      // move pi+/- and pi0s to this system
      pim.Boost(bx,by,bz);
      pi01.Boost(bx,by,bz);
      pip.Boost(bx,by,bz);
      pi02.Boost(bx,by,bz);
      rom.Boost(bx,by,bz);
      rop.Boost(bx,by,bz);
      //
      Double_t cosromrop = (rom.Px()*rop.Px()+
			    rom.Py()*rop.Py()+
			    rom.Pz()*rop.Pz())/(rom.P()*rop.P());
      //      cout <<" cosromeom = " << cosromrop 
      //	   <<" p rom = " << rom.P()
      //	   <<" p rop = " << rom.P() << endl;
      // calculate vector product
      // prod  x     y     z
      // pim   x     y     z
      // pi0   x     y     z
      TLorentzVector romplane, ropplane;
      // for ro- plane
      romplane.SetPx(pim.Py()*pi01.Pz()-pim.Pz()*pi01.Py()); 
      romplane.SetPy(-1.0*(pim.Px()*pi01.Pz()-pim.Pz()*pi01.Px())); 
      romplane.SetPz(pim.Px()*pi01.Py()-pim.Py()*pi01.Px()); 
      // for ro+ plane
      ropplane.SetPx(pip.Py()*pi02.Pz()-pip.Pz()*pi02.Py()); 
      ropplane.SetPy(-1.0*(pip.Px()*pi02.Pz()-pip.Pz()*pi02.Px())); 
      ropplane.SetPz(pip.Px()*pi02.Py()-pip.Py()*pi02.Px()); 
      // define cos between two vectors
      Double_t cosphi = (romplane.Px()*ropplane.Px()+
      			 romplane.Py()*ropplane.Py()+
      			 romplane.Pz()*ropplane.Pz())/(romplane.P()*ropplane.P());
      Double_t phi = acos(cosphi);
      // DR pi- pi0
      Double_t DRpimpi01 = pim.DeltaR(pi01);
      hdrpimpi01->Fill(DRpimpi01);
      // selection
      if(ym*yp > 0) {
	hphip->Fill(phi);
      }
      if(ym*yp < 0) {
	hphim->Fill(phi);
      }
      //
      // selections
      if(rom.Pt() < ptrocut || rop.Pt() < ptrocut) {continue;}
      if(fabs(etapip) > etacut || fabs(etapim) > etacut) {continue;}
      if(fabs(etagam1pi01) > etacut || fabs(etagam2pi01) > etacut) {continue;}    
      if(fabs(etagam1pi02) > etacut || fabs(etagam2pi02) > etacut) {continue;}    

      hdrpimpi01_s->Fill(DRpimpi01);
      hptpipm->Fill(ptpim);
      hptpipm->Fill(ptpip);
      hptgam->Fill(ptgam1pi01);
      hptgam->Fill(ptgam2pi01);
      hptgam->Fill(ptgam1pi02);
      hptgam->Fill(ptgam2pi02);

      nsel += 1.;
   }

   hdrpimpi01_s->Draw("hist");
   //   hphip->SetMinimum(0.);
   //   hphip->Draw("hist");
   hptpipm->Draw("hist");
   hptgam->Draw("hist");

   cout <<"  N events processed " << ntot << endl;
   cout << " " << endl;
   cout <<"  ========= Selections ===========" << endl;
   cout <<"     pT ro1, ro2 > " << ptrocut << endl;
   cout <<"     eta of pi+/- and photons < " << etacut << endl;
   cout << " " << endl;
   cout <<"  N selected events = " << nsel << endl;
}
